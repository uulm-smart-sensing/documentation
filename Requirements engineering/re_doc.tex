\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage[margin=2cm,a4paper,headsep=1.2cm]{geometry}
\usepackage{ifthen}
\usepackage{fancyhdr}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{arrows.meta}
\usepackage{graphicx}


\renewcommand{\baselinestretch}{1.1}
\setlength{\parindent}{0pt}
\setlength{\parskip}{1em}

\setlength{\headheight}{1cm}
\setlength{\headwidth}{\textwidth}

\makeatletter
\newcommand{\labeltext}[2]{%
  \@bsphack
  \csname phantomsection\endcsname % in case hyperref is used
  \def\@currentlabel{#1}{\label{#2}}%
  \@esphack
}
\makeatother    

\newcommand{\prio}[1]{\ifthenelse{\equal{#1}{1}}{low}{\ifthenelse{\equal{#1}{2}}{medium}{\ifthenelse{\equal{#1}{3}}{high}{\textbf{INVALID!}}}}\relax}

\newcounter{fr}
\newcommand{\fr}[8]{
\refstepcounter{fr}\label{#8}
\begin{tabularx}{16cm}{l|X}
 & \textbf{#1} \hfill \textbf{FR\arabic{fr}} \\ \hline
Description & #2\\ \hline
\ifthenelse{\equal{#3}{}}{}{Precondition & #3 \\ \hline}
\ifthenelse{\equal{#4}{}}{}{Postcondition & #4 \\ \hline}
Rationale & #5
\ifthenelse{\equal{#6}{}}{}{\\ \hline Dependencies & #6} 
\ifthenelse{\equal{#7}{}}{}{ \\ \hline Priority & \prio{#7}}
\end{tabularx}
\vspace*{0.75cm}
}

\newcommand{\actor}[4]{
\labeltext{#2}{#1}
\begin{tabularx}{16cm}{|l|X|}
\hline 
Actor: & #2 \\
\hline
Description: & #3 \\
\hline
Representative: & #4 \\
\hline
\end{tabularx}
}

%\newcommand{\rref}[1]{\ref{#1}\textsuperscript{$\rightarrow$ p. \pageref{#1}}}
\newcommand{\rref}[1]{\ref{#1}}
\newcommand{\frref}[1]{FR\ref{#1}\textsuperscript{$\rightarrow$ p. \pageref{#1}}}
\newcommand{\nfrref}[1]{QR\ref{#1}\textsuperscript{$\rightarrow$ p. \pageref{#1}}}

\newcommand{\myrule}[1]{
	\begin{tikzpicture}
		\draw[{Diamond[open]}-{Diamond[open]}, ultra thick] (0,0) to (#1, 0);
	\end{tikzpicture}
}

\renewcommand{\contentsname}{Table of Contents}

\begin{document}

% title page 
\begin{titlepage}

	\centering 
	\scshape 
	\vspace*{\baselineskip}
		
	\myrule{\linewidth}	
	\rule[1\baselineskip]{0.95\textwidth}{0.4pt}
    
    \Large
    Requirements engineering
    \normalsize
   

	\rule[-1\baselineskip]{0.95\textwidth}{0.4pt}
	\myrule{\linewidth}
	
	\vspace{2\baselineskip}

    Flutter smart sensing library \\ for medical and psychological study apps
	
	
	\vspace*{15\baselineskip}
	
	edited by
	
	\vspace{0.55\baselineskip}
	
	{\scshape Leonhard Alkewitz, Florian Gebhardt, Hermann Fr√∂hlich, \\ Mukhtar Muse, Felix Schlegel}
	
	\vspace{0.55\baselineskip}
	
	\vfill
	
\end{titlepage}


% table of contents
\tableofcontents
\thispagestyle{empty}

\newpage

% configure header and footer
\pagestyle{fancy}

\fancyhead[R]{\thepage}
\fancyhead[L]{\leftmark}
\fancyfoot{}

\section{Adding a new Feature/User Story}
\subsection{Creating a new User Story}

In order to add a new feature, it is important to understand the process of user stories, including both the user's perspective and that of the end user and developer. User stories are a proven method to describe requirements from the user's perspective. They help to define the functionality of a system or application in a clear and understandable way. Therefore, when creating a user story, the needs of the user as well as those of the end user and developer should be considered.

Once the user story is clearly formulated, you can move on to the next step and add the feature. To do this, you should first identify the right place in the existing system where the new feature can best be integrated. 

\subsection{Adding a new Feature}
To add a new feature, the whole process takes place within our GitLab environment. You can then create an issue. An issue is used to describe the new feature or desired functionality in terms of a specific task that needs to be implemented.
After the issue is created, a separate branch is created for the feature. All changes and developments take place in this separate branch to isolate the development of the feature from other changes in the main branch.

\subsubsection{Creating an Issue}
When creating the issue, you should use the appropriate template to clearly define the objective of the feature. For example, if you want the app to have a different colour, you can select the Issue Enhancement option and explain in the template what colour change you want to achieve. It is important to also describe possible solutions and alternatives, as well as provide other relevant information.

In addition to this, you should consider who should be selected as the assignee for the issue, be it yourself or another person responsible for implementing the feature. Assigning an assignee clearly establishes responsibility.

To further specify the issue and place it in the overall context of the project, you can define an Epic and a Milestone, if available. An Epic summarises related features or tasks and allows for better organisation and prioritisation. A milestone helps track the progress of the project and mark important stages.

In addition, you can add a predefined label to further mark the issue and make it easier to identify. This makes it easier to filter and categorise issues within the project management system.

To plan and track the progress of the issue, it is useful to set a date by which the issue should be completed. You should also specify the sprint iteration in which the issue is to be worked on. This allows for effective planning and coordination of workflows within the development team.

By including this additional information and details, the issue becomes more comprehensive and structured. This facilitates communication, planning and progress of the feature in the project.

\subsubsection{Reviewing an Issue}
As soon as the development of the feature is completed, a so-called merge request is created. In this merge request, the completed issue is submitted for review by another developer. The reviewer checks the code, the functionality and the implementation of the feature. In the process, possible problems, improvement requests or questions are discussed in the form of threads within the merge request.

The merge request remains open until all threads have been successfully processed and resolved. Once the reviewer is satisfied and all open issues are resolved, he can approve the merge request. This merges the issue into the main branch and integrates the new feature into the overall system.

This structured approach ensures that all changes and developments are thoroughly reviewed and discussed before they enter the main branch. This ensures the quality and stability of the system and potential errors or inconsistencies can be identified and corrected at an early stage.

All in all, each feature is developed in its own branch, goes through the merge request process with reviews and discussions before it is finally merged into the main branch. In this way, we ensure effective collaboration and controlled integration of new features into the overall system.
\subsubsection{Weight of Issues}
The weighting of an issue is done in our regular sprint meetings, which are held every two weeks. In these meetings, we discuss together how an issue should be weighted. The weighting of an issue indicates how important it is and how much effort it requires. We use a scale of 1 to 5, with a value of 1 representing the lowest importance and least effort, while a value of 5 signals the highest importance and greatest effort.

Through this structured approach, we ensure that new features and user stories are integrated into our system effectively and professionally. This allows us to continuously improve the user experience and meet the needs and requirements of our users.

\section{Decisions about adding/removing features or user stories}
When it comes to adding or removing a feature, this is also discussed in the sprint meeting and then decided. It happens that certain features have to be removed, either because they are no longer in line with our software design document or do not fit our implementation as they are considered superfluous. It is the same with the integration of features. We have found that in some cases we were missing certain functionalities of which we had no prior knowledge and which had to be added subsequently.




\end{document}
