\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{svg}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage[margin=2cm,a4paper,headsep=1.2cm]{geometry}
\usepackage{ifthen}
\usepackage{fancyhdr}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{arrows.meta}

\renewcommand{\baselinestretch}{1.1}
\setlength{\parindent}{0pt}
\setlength{\parskip}{1em}

\setlength{\headheight}{1cm}
\setlength{\headwidth}{\textwidth}

\makeatletter
\newcommand{\labeltext}[2]{%
  \@bsphack
  \csname phantomsection\endcsname % in case hyperref is used
  \def\@currentlabel{#1}{\label{#2}}%
  \@esphack
}
\makeatother    

\newcommand{\prio}[1]{\ifthenelse{\equal{#1}{1}}{low}{\ifthenelse{\equal{#1}{2}}{medium}{\ifthenelse{\equal{#1}{3}}{high}{\textbf{INVALID!}}}}\relax}

\newcounter{fr}
\newcommand{\fr}[8]{
\refstepcounter{fr}\label{#8}
\begin{tabularx}{16cm}{l|X}
 & \textbf{#1} \hfill \textbf{FR\arabic{fr}} \\ \hline
Description & #2\\ \hline
\ifthenelse{\equal{#3}{}}{}{Precondition & #3 \\ \hline}
\ifthenelse{\equal{#4}{}}{}{Postcondition & #4 \\ \hline}
Rationale & #5
\ifthenelse{\equal{#6}{}}{}{\\ \hline Dependencies & #6} 
\ifthenelse{\equal{#7}{}}{}{ \\ \hline Priority & \prio{#7}}
\end{tabularx}
\vspace*{0.75cm}
}

\newcommand{\actor}[4]{
\labeltext{#2}{#1}
\begin{tabularx}{16cm}{|l|X|}
\hline 
Actor: & #2 \\
\hline
Description: & #3 \\
\hline
Representative: & #4 \\
\hline
\end{tabularx}
}

%\newcommand{\rref}[1]{\ref{#1}\textsuperscript{$\rightarrow$ p. \pageref{#1}}}
\newcommand{\rref}[1]{\ref{#1}}
\newcommand{\frref}[1]{FR\ref{#1}\textsuperscript{$\rightarrow$ p. \pageref{#1}}}
\newcommand{\nfrref}[1]{QR\ref{#1}\textsuperscript{$\rightarrow$ p. \pageref{#1}}}

\newcommand{\myrule}[1]{
	\begin{tikzpicture}
		\draw[{Diamond[open]}-{Diamond[open]}, ultra thick] (0,0) to (#1, 0);
	\end{tikzpicture}
}

\renewcommand{\contentsname}{Table of Contents}

\begin{document}

% title page 
\begin{titlepage}

	\centering 
	\scshape 
	\vspace*{\baselineskip}
		
	\myrule{\linewidth}	
	\rule[1\baselineskip]{0.95\textwidth}{0.4pt}
    
    \Large
    Design Documentation
    \normalsize
   

	\rule[-1\baselineskip]{0.95\textwidth}{0.4pt}
	\myrule{\linewidth}
	
	\vspace{2\baselineskip}

    Flutter smart sensing library \\ for medical and psychological study apps
	
	
	\vspace*{15\baselineskip}
	
	edited by
	
	\vspace{0.55\baselineskip}
	
	{\scshape Leonhard Alkewitz, Florian Gebhardt, Hermann Fr√∂hlich, \\ Mukhtar Muse, Felix Schlegel}
	
	\vspace{0.55\baselineskip}
	
	\vfill
	
\end{titlepage}


% table of contents
\tableofcontents
\thispagestyle{empty}

\newpage

% configure header and footer
\pagestyle{fancy}

\fancyhead[R]{\thepage}
\fancyhead[L]{\leftmark}
\fancyfoot{}

\section{Introduction}
This document lists all the architectures for the Flutter Smart Sensing Library. Each diagram includes a description of why it was designed in that way and why certain changes were necessary. Every change is listed in this document.
\section{Software Architecture}
This section covers the software architecture. It is split into two core components: the Smart Sensing Library and the Sensing Plugin. The reason for this is that we have one component to get and read sensor data in a platform-independent way, while the other component represents most of the smart features like storage and filtering of values.

\subsection{Smart Sensing Library}
The Smart Sensing Library contains most of the features requested by the customer. It serves as the primary reference point to read, save and manipulate sensor data. Its design is inspired by the pipe and filter architecture. That way the customer can chain different filters on one dataset. The library is split into three main components: BufferManager, FilterTools, and API. The API has all public methods that can be used by the customer to subscribe to sensors and manipulate sensor data. The BufferManager is responsible for managing all sensor data streams and writing them into the database. It also contains a buffer cache for faster access times. The FilterTools are used to apply different filters to the sensor data.

%Explaination for Storage plugin is missing%
\subsubsection{Version 1}
\begin{figure}[ht]
\includegraphics[width=1\textwidth]{Graphics/SmartSensingLibraryOld.png}
\caption{\label{fig:bild1}Version 1.0}
\end{figure}
\subsubsection{Version 1.1}
There was an architectural change made where the Buffermanager and FilterTools were wrapped around a new component called IOManager.
The reason for this change is that the coordination between the API, FilterTools, and BufferManager was not considered while creating the first iteration. The IOManager is now the primary communication point between the API and the underlying services.
\begin{figure}[ht]
\includegraphics[width=1\textwidth]{Graphics/SmartSensingLibraryNew.png}
\caption{\label{fig:bild2} Version 1.1}
\end{figure}
\newpage
\subsection{Sensing Plugin}
The Sensing Plugin is responsible for getting sensor data from iOS and Android devices. It's split into two main parts: the platform-specific code and the Flutter code. The platform-specific code is responsible for getting sensor data from each device using factory methods provided by the corresponding operating system. These methods can then be called by the Flutter code using method channels. In the Flutter code, the data is unified so that the Smart Sensing Library can work with the data. The Sensor Manager has two main components. The Command Caller is responsible for delegating customer request like sensor subscription. The Sensor Event Subscriber handels the return of the subscriptions.
\subsubsection{Version 1}
\begin{figure}[ht]
\includegraphics[width=1\textwidth]{Graphics/SmartSensingPluginOld.png}
\caption{\label{fig:bild3} Version 1.0}
\end{figure}

\subsubsection{Version 1.1}
There was an architectural change made where the preprocessing is now part of the SensorManager. The reason for this change is that the preprocessor should be a component for the SensorManager to use. In the first iteration, the Preprocessor was seen as a single instance that would process all data, but it was later reconsidered that it would be more beneficial to use one preprocessor for each sensor. This allows for easier configuration of each sensor's output.
\begin{figure}[ht]
\includegraphics[width=1\textwidth]{Graphics/SmartSensingPluginNew.png}
\caption{\label{fig:bild4} Version 1.1}
\end{figure}

\newpage
\section{Class Diagramms}
This section covers the class diagrams for each component. Each diagram includes a description of the design choices made for that component.

\subsection{IOManager}
The IOManager component manages all functions related to data storage and transfer. It is the main component for the Smart Sensing Library.
\begin{figure}[ht]
\centering
\includesvg[width=0.9\textwidth]{Graphics/CIOManager}
\caption{\label{fig:bild5} IOManager Component}
\end{figure}


\subsubsection{IOManager}
The IOManager is implemented using the Singleton pattern. The reason for this is that sensor data should be controlled by only one component, not multiple, to prevent multiple access to data streams. There is always only one IOManager present in the Smart Sensing Library. It controls all data operations related to sensor data.
\begin{figure}[ht]
\centering
\includesvg[width=.6\textwidth]{Graphics/IOManager}
\caption{\label{fig:bild6} IOManager}
\end{figure}

\subsubsection{BufferManager}
The BufferManager class functions as a cache for currently used data. All new data is first saved into its buffer. If it becomes full, the IOManager takes its current content and saves it to the database if necessary. The Buffer Manager only contains sensor data that hasn't been modified by filters, this way the data can be reused by different functions.
\begin{figure}[ht]
\centering
\includesvg[width=0.6\textwidth]{Graphics/BufferManager}
\caption{\label{fig:bild7} BufferManager}
\end{figure}

\newpage
\subsubsection{FilterTools}
The FilterTools are used to modify the data from the BufferManager by deep-copying the needed values. After the initial copy, filters can be chained to create more complex queries. The FilterTools provide the only means for accessing the data.
\begin{figure}[ht]
\centering
\includesvg[width=0.6\textwidth]{Graphics/FilterTools}
\caption{\label{fig:bild8} FilterTools}
\end{figure}
\newpage

\subsection{SensorManager}
The SensorManager component serves as the interface between Dart code and platform-specific code. It offers the ability to subscribe and unsubscribe to sensor data streams and preprocesses the data to ensure that Android and iOS return consistent value types. The preprocessing can be configured as needed.
\begin{figure}[ht]
\centering
\includesvg[width=0.9\textwidth]{Graphics/CSensorManager}
\caption{\label{fig:bild9} SensorManager Component}
\end{figure}

\subsubsection{SensorManager}
The SensorManager class is the central control unit for the component and follows the singleton design pattern. It manages all aspects related to subscribing and unsubscribing to sensors.
\begin{figure}[ht]
\centering
\includesvg[width=0.6\textwidth]{Graphics/Sensormanager}
\caption{\label{fig:bild10} SensorManager}
\end{figure}

\subsubsection{Sensor}
This class is representing a sensor.
\begin{figure}[ht]
\centering
\includesvg[width=0.6\textwidth]{Graphics/Sensor}
\caption{\label{fig:bild11} Sensor}
\end{figure}

\subsubsection{SensorPropertyValidator}
The SensorPropertyValidator class ensures that the specified precision and time interval are maintained.
\begin{figure}[ht]
\centering
\includesvg[width=0.6\textwidth]{Graphics/SensorPropertyValidator}
\caption{\label{fig:bild12} SensorPropertyValidator}
\end{figure}
\newpage

\subsubsection{Preprocessor}
The Peprocessor class ensures that Android and iOS return consistent value types. It can be configured with the SensorConfig.
\begin{figure}[ht]
\centering
\includesvg[width=0.6\textwidth]{Graphics/PreProcessor}
\caption{\label{fig:bild13} Preprocessor}
\end{figure}

\subsubsection{SensorConfig}
The SensorConfig class holds various configurations for the preprocessor, including the time interval, precision, and target unit.
\begin{figure}[ht]
\centering
\includesvg[width=0.6\textwidth]{Graphics/SensorConfig}
\caption{\label{fig:bild14} SensorConfig}
\end{figure}

\newpage
\subsubsection{SensorDataSubscriber}
The SensorDataSubscriber class manages multiple subscriptions and is utilized by the SensorManager class.
\begin{figure}[ht]
\centering
\includesvg[width=0.6\textwidth]{Graphics/DataSubscriber}
\caption{\label{fig:bild15} Preprocessor}
\end{figure}

\subsubsection{SensorData}
The SensorData class represents the data received from a sensor and serves as the data model for the document-based database.
\begin{figure}[ht]
\centering
\includesvg[width=0.6\textwidth]{Graphics/SensorData}
\caption{\label{fig:bild16} Preprocessor}
\end{figure}

\newpage
\section{Processes}
\subsection{Sequence Diagrams}
This section contains sequence diagrams for getting and modifying data.
\subsection{Starting a Sensor}
\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{Graphics/SeqStart.png}
\caption{\label{fig:bild17} Starting sequence diagram}
\end{figure}

\newpage
\subsection{Getting Data via a filter}
\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{Graphics/SeqFilter.png}
\caption{\label{fig:bild18} Filtering sequence diagram}
\end{figure}
\end{document}